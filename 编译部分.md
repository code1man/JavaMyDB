## 编译阶段：

### 一、总体流程

系统按经典编译器前端分层：输入 SQL 文本 → 词法分析（Lexer）→ 语法分析（Parser）→ 语义/计划构建（PlanBuilder）→ 执行器（Executor）。每层职责单一、耦合低，便于扩展与调试。

### 二、词法分析（Lexer）

Lexer 将输入划分为 token：KEYWORD、IDENTIFIER、CONSTANT、STRING、OPERATOR、DELIMITER 等。关键点：关键字表大小写不敏感；识别单行注释（--）和多行注释（/.../）；支持 SQL 风格字符串（单引号、双单引号转义）；对每个 token 记录行号和列号，便于错误定位与诊断。

### 三、语法分析（Parser）

采用手写 LL(1) 风格的预测分析，文法经过左因子化与尾部化以消除二义性。已实现的语句子集包括：CREATE DATABASE、CREATE TABLE（多列、TypeDef 支持 INT 与 VARCHAR(n)）、USE、INSERT（全列与显式列）、SELECT（多列或 EVERYTHING）、UPDATE、DELETE、DROP（TABLE/DATABASE）、GRANT（基本权限授予）。Parser 使用 FIRST/FOLLOW 集进行预测，遇错时返回“期望 X，实际 Y，行:列”的友好错误信息。注意：目前不支持 JOIN 语句解析，相关产生式与解析动作未启用。

### 四、语义分析与执行计划（PlanBuilder → ExecutionPlan）

Parser 在规约时调用 PlanBuilder，把语法结构映射为 ExecutionPlan 对象：OperationType 指明操作（CREATE_TABLE/INSERT/QUERY 等），并填充对应字段（tableName、columns、values、condition、grants、databaseName、userName 等）。Executor 根据 ExecutionPlan 调用底层存储引擎完成操作。该中间表示足够扁平，便于在后端实现权限检查、简单优化或执行统计。

### 五、错误处理与可观测性

每个阶段均保留位置信息；Lexer/Parser 均产生明确错误；系统可打印 FIRST/FOLLOW 集用于调试文法冲突；生成的 ExecutionPlan 可序列化查看，有助于单元测试。

### 执行器模块

### CommandToPlanConverter

**职责**：将解析后的命令 `ParsedCommand` 转换为执行计划 `ExecutionPlan`，根据命令类型设置相应参数，充当命令与执行器之间的桥梁。

### ExecutionPlan

**职责**：描述数据库操作的执行计划，封装操作类型、表名、列定义、条件、别名等信息，作为执行器与存储引擎的统一数据结构。

###  ExecutionResult

**职责**：封装执行结果，包含成功标志、提示信息、返回数据和受影响行数，统一描述执行器的运行反馈，方便上层处理与显示。

###  Executor

**职责**：执行器核心类，根据 `ExecutionPlan` 调用存储引擎的实际方法，处理数据库的增删改查等操作，并返回统一的 `ExecutionResult`。

###  ExecutorException

**职责**：执行器专用异常类，用于封装执行过程中的错误信息，支持附带底层异常，保证错误能被捕获和定位。